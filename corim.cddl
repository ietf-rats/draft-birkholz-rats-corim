;Sequence of CDDL definitions:
;cat concise-rim.cddl signed-corim.cddl unsigned-corim.cddl concise-mid-tag.cddl signed-coswid.cddl concise-swid-tag.cddl > corim.cddl
concise-reference-integrity-manifest =  #6.47111(unsigned-corim) / #6.47112(signed-corim)

signed-corim = #6.18(COSE-Sign1-corim)

cose-label = int / tstr
cose-values = any

protected-signed-corim-header = {
  1 => int,                      ; algorithm identifier
  3 => "application/rim+cbor",   ; content type identifier
  4 => bstr,                     ; key identifier of issuer?
  corim-meta-key => corim-meta   ; corim signature attributes
  * cose-label => cose-values,
}
corim-meta-key = 5 ; scoped to protected-signed-corim-header map (XXX 5 is already taken)

unprotected-signed-corim-header = {
  * cose-label => cose-values,
}

COSE-Sign1-corim = [
  protected: bstr .cbor protected-signed-corim-header,
  unprotected: unprotected-signed-corim-header,
  payload: bstr .cbor unsigned-corim,
  signature: bstr,
]

unsigned-corim = {
  corim-id => corim-id-type,
  tags => concise-tag / [2* concise-tag],
  ? dependent-rims => corim-locator / [2* corim-locator], ; hint for finding manifest files
  * $$unsigned-corim-extension
}
corim-id = 123 ; TBD
tags = 97
dependent-rims = 122; TBD

corim-id-type = tstr / bstr .size 16 ; **Note: Do we want a %6.CT reservation?**

corim-meta = {
  signer => entity-entry, ; entity-entry is pointing to the manifest issuer - compare tag-metadata tag-issuer these are different things
  ? validity-entry,
  ? deny-id => corim-id-type, ; used for revocation - NOTE(tho) I'm not sure I understand how is this supposed to work?
}
signer = 98
deny-id = 99

validity-entry = (
  ? not-before => time,
  not-after => time,
)
not-before=100
not-after=101

corim-locator = {
  href => any-uri, ; e.g. https://isv.example.mymodule.corim
  ? thumbprint => hash-entry, ; the digest computed over mymodule.corim
  ; **Note:should there be an extension point here?**
}

concise-tag = #6.47116(signed-coswid) / #6.47117(concise-mid-tag)
; NOTE(henk) does a concise-mid-tag by itself should be allowed to be singed the same as a CoSWID tag?
concise-mid-tag = {
  tag-metadata,
  ? module-name => text,
  ? module-type => module-type-type,
  ? module-version => text .default '0.0',
  ? version-scheme => $version-scheme, ; defined in coswid
  ? entity => entity-entry / [2* entity-entry], ; defined in coswid
  ? linked-tags => linked-tags-entry / [2* linked-tags-entry], ; dependent coswid and comid tags.
  ? claims => claims-entry / [2* claims-entry], ; claims may be omitted for manifests that only capture dependencies to other manifests
  global-attributes, ; NOTE(tho) is this needed? ISTM $$comid-extension should be enough
  * $$comid-extension
}
module-name=101
module-type=102
module-version=103
;version-scheme = 14
;entity=2
linked-tags=106
claims=107

tag-metadata = (
  tag-id => $tag-id-type,
  tag-version => integer .default 0,
  ; Verifier can compute digest of the CBOR encoding of this concise-tag
  ; Verifier can capture tag-issuer Note: What is the right format X.509 Issuer, DID, PEN ???
  * $$tag-metadata-extension
)
;tag-id = 0
;tag-version = 12
$tag-id-type /= type-one
$tag-id-type /= type-two
type-one = 0
type-two = 1
;tag-id-type = tstr / bstr .size 16 ; **Note: Do we want a $6.TT reservation?**

module-type-type /= tagged-bytes
module-type-type /= uuid-bytes
module-type-type /= implementation-id-bytes

tagged-bytes = #6.111(bytes) ; BER encoded OID
uuid-bytes = #6.37(bytes .size 16) ; see RFC4412
implementation-id-bytes = #6.47115(bytes .size 32) ; see draft-tschofenig-rats-psa-token-06 - NOTE(tho) if we don't carry PSA identity endorsements in CoRIMs this is no longer needed.

linked-tags-entry = {
  tag-id => $tag-id-type,
  tag-rel => $comid-rel / $rel,  ; NOTE(tho) let's think about how to deal with ambiguity of overlapping codepoint spaces
  ? tag-thumbprint => hash-entry, ; digest of the CBOR encoding of the concise-tag
  ? tag-issuer => tag-issuer-type,
}
tag-rel=121
tag-thumbprint = 199 ; NOTE(tho) - randomly assigned number: check this for clashes
tag-issuer = 200 ; NOTE(tho) - randomly assigned number: check this for clashes

; DID, PEN ??? Bob is saying I expect this tag to be provided (signed by) by Alice
tag-issuer-type = "TODO"

$comid-rel /= "submodule" ; a module that depends on this module
$comid-rel /= "peermodule" ; a module that this module can be access - NOTE(tho) is this needed?  It seems to be implied unambiguously by the fact that modules share the same parent...
$comid-rel /= "rootmodule" ; a module that contains this module
$comid-rel /= "parentmodule" ; a module that directly contains this module
$comid-rel /= -256..64436 / text ; **note: do we need 'text' as that opens a door for confusion**

claims-entry = {
  ? ref-claims => reference-value  / [2* reference-value], ;any reference-value entry can match evidence
  ? end-claims => endorsed-value / [2* endorsed-value],
  * $$claims-entry-extension,
}
ref-claims=108
end-claims=109

; NOTE(tho) from a syntactic PoV reference-value and endorsed-value are extremely similar.  I'm wondering why do we need to keep them separate?
; NOTE(henk) I very much hope that they are similar: endorsements are on the "evidence side" of things as they kick in when the Attester cannot create evidence about the characteristics of its own components (roots of trust). Reference-values are the things that you compare the "evidence side" with. So endorsements cannot be part of the "reference side". They have to look similar/identical though - otherwise the comparison becomes complex and brittle.

element-name = (
    ? label => text,
    ? vendor => text, ; namespace authority designation
    ? type => module-type-type, ; Note: 'type' SHOULD include a namespace authority if 'vendor' is ommitted
    ? model => text,
    ? layer => int,
    ? index => int,
; **note: An extension point in element-name confuses verifiers' ability to match against evidence**
)
; label is defined in coswid schema (q: should we use a different value if the semantics differ?)
; type is defined in coswid schema
vendor=110
model=111
layer=112
index=113

element-value = (
  ? version => text,
  ? svn => int,
  ? raw-value-entry,
  ? digests => digests-entry,
  ? flags => bytes .bits operational-flags,
;  * $$element-value-extension ; **note do we need an extension point in element-value given there are extension points in endorsed-value and reference-value?**
)
version=114
svn=115
digests=116
flags=117

endorsed-value = {
  element-name,
  ? element-value, ; one endorser benefits from the element-value of another endorser
  ? any-attribute, ; defined in coswid schema - **note: this can be removed if we opt for using the extension point instead. ** NOTE(tho): agree
  * $$endorsed-value-extension ;How do vendor specific schemas allocate indices (keys)? We need to specify a range of keys with rules 'first come first served'
}

;**Note: a collection of reference values can be modeled using multiplicity of tags and/or claims, but we need to verify how to apply AND and OR logic for matching.**

reference-value = {
  element-name,
  element-value,
  * $$reference-value-extension,
}

raw-value-entry = (
  raw-value => bstr,
  ? raw-value-mask => bstr,
)
raw-value=118
raw-value-mask=119

operational-flags = &( ;requires functional compare
  not-configured: 0,
  not-secure: 1,
  recovery: 2,
  debug: 3,
)

digests-entry = [ hash-entry / [2* hash-entry] ]
; hash-entry is defined in coswid schema

signed-coswid = #6.18(COSE-Sign1-coswid)

cose-label = int / tstr
cose-values = any

protected-signed-coswid-header = {
    1 => int,                      ; algorithm identifier
    3 => "application/swid+cbor",
    4 => bstr,                     ; key identifier
    * cose-label => cose-values,
}

unprotected-signed-coswid-header = {
    * cose-label => cose-values,
}

COSE-Sign1-coswid = [
    protected: bstr .cbor protected-signed-coswid-header,
    unprotected: unprotected-signed-coswid-header,
    payload: bstr .cbor concise-swid-tag,
    signature: bstr,
]
concise-swid-tag = {
  tag-id => text / bstr .size 16,
  tag-version => integer,
  ? corpus => bool,
  ? patch => bool,
  ? supplemental => bool,
  software-name => text,
  ? software-version => text,
  ? version-scheme => $version-scheme,
  ? media => text,
  ? software-meta => software-meta-entry / [ 2* software-meta-entry ],
  entity => entity-entry / [ 2* entity-entry ],
  ? link => link-entry / [ 2* link-entry ],
  ? payload-or-evidence,
  global-attributes,
  * $$coswid-extension,
}

payload-or-evidence //= ( payload => payload-entry )
payload-or-evidence //= ( payload => [ 2* payload-entry ] )
payload-or-evidence //= ( evidence => evidence-entry )
payload-or-evidence //= ( evidence => [ 2* evidence-entry ] )

any-uri = text
label = text / int

$version-scheme /= multipartnumeric
$version-scheme /= multipartnumeric-suffix
$version-scheme /= alphanumeric
$version-scheme /= decimal
$version-scheme /= semver
$version-scheme /= uint / text

any-attribute = (
  label => text / int / [ 2* text ] / [ 2* int ]
)

global-attributes = (
  ? lang => text,
  * any-attribute,
)

hash-entry = [ 
  hash-alg-id: int,
  hash-value: bytes,
]

entity-entry = {
  entity-name => text,
  ? reg-id => any-uri,
  role => $role / [ 2* $role ],
  ? thumbprint => hash-entry,
  global-attributes,
  * $$entity-extension,
}

$role /= tag-creator
$role /= software-creator
$role /= aggregator
$role /= distributor
$role /= licensor
$role /= maintainer
$role /= uint / text

link-entry = {
  ? artifact => text,
  href => any-uri,
  ? media => text,
  ? ownership => $ownership,
  rel => $rel,
  ? media-type => text,
  ? use => $use,
  global-attributes,
  * $$link-extension
}

$ownership /= shared
$ownership /= private
$ownership /= abandon
$ownership /= uint / text

$rel /= ancestor
$rel /= component
$rel /= feature
$rel /= installationmedia
$rel /= packageinstaller
$rel /= parent
$rel /= patches
$rel /= requires
$rel /= see-also
$rel /= supersedes
$rel /= supplemental
$rel /= -256..64436 / text

$use /= optional
$use /= required
$use /= recommended
$use /= uint / text

software-meta-entry = {
  ? activation-status => text,
  ? channel-type => text,
  ? colloquial-version => text,
  ? description => text,
  ? edition => text,
  ? entitlement-data-required => bool,
  ? entitlement-key => text,
  ? generator => text,
  ? persistent-id => text,
  ? product => text,
  ? product-family => text,
  ? revision => text,
  ? summary => text,
  ? unspsc-code => text,
  ? unspsc-version => text,
  global-attributes,
  * $$software-meta-extension,
}

path-elements-group = ( ? directory => directory-entry / [ 2* directory-entry ],
                        ? file => file-entry / [ 2* file-entry ],
                      )

resource-collection = (
  path-elements-group,
  ? process => process-entry / [ 2* process-entry ],
  ? resource => resource-entry / [ 2* resource-entry ],
  * $$resource-collection-extension,
)

file-entry = {
  filesystem-item,
  ? size => uint,
  ? file-version => text,
  ? hash => hash-entry,
  * $$file-extension,
}

directory-entry = {
  filesystem-item,
  ? path-elements => { path-elements-group },
  * $$directory-extension,
}

process-entry = {
  process-name => text,
  ? pid => integer,
  global-attributes,
  * $$process-extension,
}

resource-entry = {
  type => text,
  global-attributes,
  * $$resource-extension,
}

filesystem-item = (
  ? key => bool,
  ? location => text,
  fs-name => text,
  ? root => text,
  global-attributes,
)

payload-entry = {
  resource-collection,
  global-attributes,
  * $$payload-extension,
}

evidence-entry = {
  resource-collection,
  ? date => time,
  ? device-id => text,
  global-attributes,
  * $$evidence-extension, 
}

; "global map member" integer indexes
tag-id = 0
software-name = 1
entity = 2
evidence = 3
link = 4
software-meta = 5
payload = 6
hash = 7
corpus = 8
patch = 9
media = 10
supplemental = 11
tag-version = 12
software-version = 13
version-scheme = 14
lang = 15
directory = 16
file = 17
process = 18
resource = 19
size = 20
file-version = 21
key = 22
location = 23
fs-name = 24
root = 25
path-elements = 26
process-name = 27
pid = 28
type = 29
entity-name = 31
reg-id = 32
role = 33
thumbprint = 34
date = 35
device-id = 36
artifact = 37
href = 38
ownership = 39
rel = 40
media-type = 41
use = 42
activation-status = 43
channel-type = 44
colloquial-version = 45
description = 46
edition = 47
entitlement-data-required = 48
entitlement-key = 49
generator = 50
persistent-id = 51
product = 52
product-family = 53
revision = 54
summary = 55
unspsc-code = 56
unspsc-version = 57

; "version-scheme" integer indexes
multipartnumeric = 1
multipartnumeric-suffix = 2
alphanumeric = 3
decimal = 4
semver = 16384

; "role" integer indexes
tag-creator=1
software-creator=2
aggregator=3
distributor=4
licensor=5
maintainer=6

; "ownership" integer indexes
shared=1
private=2
abandon=3

; "rel" integer indexes
ancestor=1
component=2
feature=3
installationmedia=4
packageinstaller=5
parent=6
patches=7
requires=8
see-also=9
supersedes=10
; supplemental=11 ; this is already defined earlier

; "use" integer indexes
optional=1
required=2
recommended=3
