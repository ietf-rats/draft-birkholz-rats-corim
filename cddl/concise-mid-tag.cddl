; Notes:
; - entity and entity-entry are defined by CoSWID
; - linked-tags contains references to dependent CoSWID and CoMID tags
; - claims may be omitted for manifests that only capture dependencies to other
;   manifests
concise-mid-tag = {
  ? language => text,
  tag-metadata => tag-metadata-type,
  ? module-metadata => module-metadata-type,
  ? entity => one-or-many<entity-entry>,
  ? linked-tags => one-or-many<linked-tags-entry>,
  ? claims => claims-entry,
  * $$comid-extension
}

one-or-many<T> = T / [ 2* T ]

language = 0
tag-metadata = 1
module-metadata = 2

tag-metadata-type = {
  0 => $tag-id-type,
  1 => tag-version-type,
  * $$tag-metadata-extension,
}

$tag-id-type /= tstr
$tag-id-type /= bstr .size 16

tag-version-type = integer .default 0

module-metadata-type = {
  ? 0 => module-name,
  ? 1 => $module-type,
  ? 2 => module-version,
  ? 3 => module-vendor,
  ? 4 => module-index,
  * $$module-metadata-extension
}

module-name = text

$module-type /= tagged-oid
$module-type /= tagged-uuid
$module-type /= tagged-impl-id

;
; From draft-ietf-cbor-tags-oid (TBD, roid and pen)
;
oid = bstr
tagged-oid = #6.111(bstr)

;
; From https://github.com/lucas-clemente/cbor-specs/blob/master/uuid.md
;
uuid = bytes .size 16
tagged-uuid = #6.37(uuid)

;
; From draft-tschofenig-rats-psa-token
;
impl-id = bytes .size 32
tagged-impl-id = #6.47115(impl-id)

;
; From draft-ietf-rats-eat
;
ueid = bstr .size 33
tagged-ueid = #6.48000(ueid)

; version-scheme defined in CoSWID
module-version = {
  0 => text .default '0.0.0', ; version
  1 => $version-scheme,       ; version-scheme
}

module-vendor = text

module-index = uint

linked-tags = 106

linked-tags-entry = {
  0 => $tag-id-type,
  1 => $tag-rel-type,
  ; tag thumbprint, i.e., digest of the CBOR encoding of the concise-tag
  ? 2 => hash-entry,
  ; verification key associated with the tag issuer
  ? 3 => tag-issuer-type,
}

; Bob is saying: I expect this tag to be provided (signed by) by Alice.
; The COSE keyset only contains raw / certified public keys.
tag-issuer-type /= COSE_KeySet

$tag-rel-type /= comid-includes
$tag-rel-type /= comid-or-includes
$tag-rel-type /= comid-supplements
$tag-rel-type /= comid-updates
$tag-rel-type /= comid-replaces
$tag-rel-type /= comid-patches

; The current module has additional module(s) identified by the linked tag(s).
; The union of all modules describes an acceptable device.
comid-includes = 0
; The current module has additional module(s) identified by the linked tag(s)
; that describe alternative acceptable modules. At least one of the
; alternatives is included to describe an acceptable device.
comid-or-includes = 1
; The current module has additional claims that augment the claim set of the
; target module. The current tag module information must match the target
; module for the claims to be combined under the target.
comid-supplements = 2
; The current module contains claims that fully replace the target module
; claims. This is applied when the module is updated or changes in some
; fashion.
comid-updates = 3
; The current tag contains corrections to a previously issued tag. This tag
; replaces the target tag. The tag-id remains unchanged. The tag-version is
; incremented.
comid-replaces = 4
; The current module contains claims that partially replace the target module
; claims. This is applied when the module is updated or changes in some
; fashion.  The target module contains both valid and replaced claims.
comid-patches = 5

claims = 107

; Notes:
; - any reference-value entry can match evidence
claims-entry = {
  ? ref-claims => one-or-many<reference-value>
  ? end-claims => one-or-many<endorsed-value>
  ? identity-claims => one-or-many<identity-value>
  ? instance-claims => one-or-many<instance-value>
  * $$claims-entry-extension
}

ref-claims = 0
end-claims = 1
identity-claims = 2
instance-claims = 3

identity-value = {
  ? 0 => $device-id-type, ; device id
  1 => COSE_KeySet, ; key material
}

$device-id-type /= tagged-ueid
$device-id-type /= tagged-uuid
; Note: is there a #6.4711 definition for hardwaremodulename RFC4108?

instance-value = {
  ? 0 => element-name
  $$instance-claim-choice
}

$$instance-claim-choice = (
  mac-addr-key => mac-addr-type //
  ip-addrs-key => one-or-many<ip-addr-type> //
  serial-number-key => serial-number-type //
  ueid-key => ueid //
  uuid-key => uuid
)

mac-addr-key = 1
ip-addrs-key = 2
serial-number-key = 3
ueid-key = 4
uuid-key = 5

ip-addr-type = ip4-addr-type / ip6-addr-type
ip4-addr-type = bytes .size 4
ip6-addr-type = bytes .size 16

mac-addr-type = bytes .size 6

serial-number-type = text

; Note: are there other well defined types under #6.4711 or EAT etc...

; Notes:
; - vendor is the namespace authority designation
; - type SHOULD include a namespace authority if vendor is ommitted
; - An extension point in element-name confuses verifiers' ability to match
;   against evidence
; - label is defined in coswid schema (q: should we use a different value if
;   the semantics differ?)
; - type is defined in coswid schema
element-name = {
  ? label => text,
  ? vendor => text,
  ? type => $module-type,
  ? model => text,
  ? layer => int,
  ? index => int,
}

vendor = 110
model = 111
layer = 112
index = 113

; Notes:
; - do we need an extension point in element-value given there are extension
;   points in endorsed-value and reference-value?
element-value = {
  ? version => text,
  ? svn => int,
  ? raw-value-entry,
  ? digests => digests-entry,
  ? flags => bytes .bits operational-flags,
}

version = 0
svn = 1
digests = 2
flags = 3

raw-value-entry = (
  raw-value => bstr,
  ? raw-value-mask => bstr,
)

raw-value = 4
raw-value-mask = 5

; Notes:
; - one endorser benefits from the element-value of another endorser
; - any-attribute is defined in CoSWID (this can be removed if we opt for using
;   the extension point instead. NOTE(tho): agree
; - How do vendor specific schemas allocate indices (keys)? We need to specify
;   a range of keys with rules 'first come first served'
endorsed-value = {
  0 => element-name,
  ? 1 => element-value,
  ? any-attribute,
  * $$endorsed-value-extension
}

; Notes:
; - a collection of reference values can be modeled using multiplicity of tags
;   and/or claims, but we need to verify how to apply AND and OR logic for
;   matching
reference-value = {
  0 => element-name,
  1 => element-value,
  * $$reference-value-extension,
}

; Notes:
; - requires functional compare
operational-flags = &(
  not-configured: 0,
  not-secure: 1,
  recovery: 2,
  debug: 3,
)

; Notes:
; - hash-entry is defined in CoSWID schema
digests-entry = [ hash-entry / [2* hash-entry] ]
