; Notes:
; - entity and entity-entry are defined by CoSWID
; - linked-tags contains references to dependent CoSWID and CoMID tags
; - claims may be omitted for manifests that only capture dependencies to other
;   manifests
concise-mid-tag = {
  ? language => text,
  tag-metadata => tag-metadata-type,
  ? module-metadata => module-metadata-type,
  ? comid-entity => one-or-many<entity-entry>,
  ? linked-tags => one-or-many<linked-tags-entry>,
  ? claims => claims-entry,
  * $$comid-extension
}

one-or-many<T> = T / [ 2* T ]

tag-metadata-type = {
  0 => $tag-id-type,
  1 => tag-version-type,
  * $$tag-metadata-extension,
}

$tag-id-type /= tstr
$tag-id-type /= uuid

tag-version-type = integer .default 0

module-metadata-type = {
  ? 0 => module-name,
  ? 1 => $module-type,
  ? 2 => module-version,
  ? 3 => module-vendor,
  ? 4 => module-index,
  * $$module-metadata-extension
}

module-name = text

$module-type /= tagged-oid
$module-type /= tagged-uuid
$module-type /= tagged-impl-id

;
; From draft-ietf-cbor-tags-oid (TBD, roid and pen)
;
oid = bstr
tagged-oid = #6.111(bstr)

;
; From https://github.com/lucas-clemente/cbor-specs/blob/master/uuid.md
;
uuid = bytes .size 16
tagged-uuid = #6.37(uuid)

;
; From draft-tschofenig-rats-psa-token
;
impl-id = bytes .size 32
tagged-impl-id = #6.47115(impl-id)

;
; From draft-ietf-rats-eat
;
ueid = bstr .size 33
tagged-ueid = #6.48000(ueid)

; version-scheme defined in CoSWID
module-version = {
  0 => text .default '0.0.0', ; version
  1 => $version-scheme,       ; version-scheme
}

module-vendor = text

module-index = uint

linked-tags-entry = {
  0 => $tag-id-type,
  1 => $tag-rel-type,
  ; tag thumbprint, i.e., digest of the CBOR encoding of the concise-tag
  ? 2 => hash-entry,
  ; verification key associated with the tag issuer
  ? 3 => tag-issuer-type,
}

; Bob is saying: I expect this tag to be provided (signed by) by Alice.
; The COSE keyset only contains raw / certified public keys.
tag-issuer-type /= COSE_KeySet

$tag-rel-type /= comid-includes
$tag-rel-type /= comid-or-includes
$tag-rel-type /= comid-supplements
$tag-rel-type /= comid-updates
$tag-rel-type /= comid-replaces
$tag-rel-type /= comid-patches

; The current module has additional module(s) identified by the linked tag(s).
; The union of all modules describes an acceptable device.
comid-includes = 0
; The current module has additional module(s) identified by the linked tag(s)
; that describe alternative acceptable modules. At least one of the
; alternatives is included to describe an acceptable device.
comid-or-includes = 1
; The current module has additional claims that augment the claim set of the
; target module. The current tag module information must match the target
; module for the claims to be combined under the target.
comid-supplements = 2
; The current module contains claims that fully replace the target module
; claims. This is applied when the module is updated or changes in some
; fashion.
comid-updates = 3
; The current tag contains corrections to a previously issued tag. This tag
; replaces the target tag. The tag-id remains unchanged. The tag-version is
; incremented.
comid-replaces = 4
; The current module contains claims that partially replace the target module
; claims. This is applied when the module is updated or changes in some
; fashion.  The target module contains both valid and replaced claims.
comid-patches = 5

; Notes:
; - any reference-value entry can match evidence
claims-entry = {
  ? ref-claims => one-or-many<reference-value>
  ? end-claims => one-or-many<endorsed-value>
  ? identity-claims => one-or-many<identity-value>
  ? instance-claims => one-or-many<instance-value>
  * $$claims-entry-extension
}

identity-value = {
  ? 0 => $device-id-type, ; device id
  1 => COSE_KeySet, ; key material
}

$device-id-type /= tagged-ueid
$device-id-type /= tagged-uuid

; Note: is there a #6.4711 definition for hardwaremodulename RFC4108?

instance-value = {
  ? 0 => element-name
  $$instance-claim-choice
}

$$instance-claim-choice = (
  mac-addr-key => mac-addr-type //
  ip-addrs-key => one-or-many<ip-addr-type> //
  serial-number-key => serial-number-type //
  ueid-key => ueid //
  uuid-key => uuid
)

mac-addr-key = 1
ip-addrs-key = 2
serial-number-key = 3
ueid-key = 4
uuid-key = 5

ip-addr-type = ip4-addr-type / ip6-addr-type
ip4-addr-type = bytes .size 4
ip6-addr-type = bytes .size 16

mac-addr-type = bytes .size 6

serial-number-type = text

; Note: are there other well defined types under #6.4711 or EAT etc...

; Notes:
; - vendor is the namespace authority designation
; - type SHOULD include a namespace authority if vendor is omitted
element-name = {
  ? 0 => label-type
  ? 1 => vendor-type
  ? 2 => $module-type
  ? 3 => model-type
  ? 4 => layer-type,
  ? 5 => index-type,
}

label-type = text
vendor-type = text
model-type = text
layer-type = int
index-type = int

; Notes:
; - do we need an extension point in element-value given there are extension
;   points in endorsed-value and reference-value?
element-value = {
  ? 0 => version-type
  ? 1 => svn-type
  ? 2 => digests-entry
  ? 3 => flags-type
  ? raw-value-entry
}

version-type = text
svn-type = int
flags-type = bytes .bits operational-flags

raw-value-entry = (
  4 => raw-value-type
  ? 5 => raw-value-mask-type
)

raw-value-type = bstr
raw-value-mask-type = bstr

; Notes:
; - one endorser benefits from the element-value of another endorser
; - How do vendor specific schemas allocate indices (keys)? We need to specify
;   a range of keys with rules 'first come first served'
endorsed-value = {
  0 => element-name,
  ? 1 => element-value,
  * $$endorsed-value-extension
}

; Notes:
; - a collection of reference values can be modeled using multiplicity of tags
;   and/or claims, but we need to verify how to apply AND and OR logic for
;   matching
reference-value = {
  0 => element-name,
  1 => element-value,
  * $$reference-value-extension,
}

; Notes:
; - requires functional compare
operational-flags = &(
  not-configured: 0,
  not-secure: 1,
  recovery: 2,
  debug: 3,
)

; Notes:
; - hash-entry is defined in CoSWID schema
digests-entry = [ hash-entry / [2* hash-entry] ]
