concise-mid-tag = {
  ? language => text,
  tag-metadata => tag-metadata-type,
  ? module-metadata => module-metadata-type,
  ? entity => entity-entry / [2* entity-entry], ; defined in coswid
  ? linked-tags => linked-tags-entry / [2* linked-tags-entry], ; dependent coswid and comid tags.
  ? claims => claims-entry / [2* claims-entry], ; claims may be omitted for manifests that only capture dependencies to other manifests
  * $$comid-extension
}

language = 0
tag-metadata = 1
module-metadata = 2

tag-metadata-type = {
  0 => $tag-id-type,
  1 => tag-version-type,
  * $$tag-metadata-extension,
}

$tag-id-type /= tstr
$tag-id-type /= bstr .size 16

tag-version-type = integer .default 0

module-metadata-type = {
  ? 0 => module-name,
  ? 1 => $module-type,
  ? 2 => module-version,
  ? 3 => module-vendor,
  * $$module-metadata-extension
}

module-name = text

$module-type /= tagged-oid
$module-type /= tagged-uuid
$module-type /= tagged-impl-id

;
; From draft-ietf-cbor-tags-oid (TBD, roid and pen)
;
oid = bstr
tagged-oid = #6.111(bstr)

;
; From https://github.com/lucas-clemente/cbor-specs/blob/master/uuid.md
;
uuid = bytes .size 16
tagged-uuid = #6.37(uuid)

;
; From draft-tschofenig-rats-psa-token
;
impl-id = bytes .size 32
tagged-impl-id = #6.47115(impl-id)

;
; From draft-ietf-rats-eat
;
ueid = bstr .size 33
tagged-ueid = #6.48000(ueid)

module-version = {
  0 => text .default '0.0.0', ; version
  1 => $version-scheme,       ; version-scheme
}

; version-scheme defined in CoSWID

module-vendor = text

linked-tags = 106

linked-tags-entry = {
  0 => $tag-id-type,
  1 => $tag-rel-type,
  ; tag thumbprint, i.e., digest of the CBOR encoding of the concise-tag
  ? 2 => hash-entry,
  ; verification key associated with the tag issuer
  ? 3 => tag-issuer-type,
}

; Bob is saying: I expect this tag to be provided (signed by) by Alice.
; The COSE keyset only contains raw / certified public keys.
tag-issuer-type /= COSE_KeySet

$tag-rel-type /= comid-includes
$tag-rel-type /= comid-or-includes
$tag-rel-type /= comid-supplements
$tag-rel-type /= comid-updates
$tag-rel-type /= comid-replaces
$tag-rel-type /= comid-patches

; The current module has additional module(s) identified by the linked tag(s).
; The union of all modules describes an acceptable device.
comid-includes = 0
; The current module has additional module(s) identified by the linked tag(s)
; that describe alternative acceptable modules. At least one of the
; alternatives is included to describe an acceptable device.
comid-or-includes = 1
; The current module has additional claims that augment the claim set of the
; target module. The current tag module information must match the target
; module for the claims to be combined under the target.
comid-supplements = 2
; The current module contains claims that fully replace the target module
; claims. This is applied when the module is updated or changes in some
; fashion.
comid-updates = 3
; The current tag contains corrections to a previously issued tag. This tag
; replaces the target tag. The tag-id remains unchanged. The tag-version is
; incremented.
comid-replaces = 4
; The current module contains claims that partially replace the target module
; claims. This is applied when the module is updated or changes in some
; fashion.  The target module contains both valid and replaced claims.
comid-patches = 5

claims = 107

claims-entry = {
  ? ref-claims => reference-value  / [2* reference-value], ;any reference-value entry can match evidence
  ? end-claims => endorsed-value / [2* endorsed-value],
  ? id-claims => identity-value / [2* identity-value],
  * $$claims-entry-extension,
}
ref-claims=108
end-claims=109
id-claims=124

identity-value = {
  ? 0 => $device-id-type, ; device id
  1 => COSE_KeySet, ; key material
}

$device-id-type /= tagged-ueid
$device-id-type /= tagged-uuid
; Note: is there a #6.4711 definition for hardwaremodulename RFC4108?

; NOTE(tho) from a syntactic PoV reference-value and endorsed-value are extremely similar.  I'm wondering why do we need to keep them separate?
; NOTE(henk) I very much hope that they are similar: endorsements are on the "evidence side" of things as they kick in when the Attester cannot create evidence about the characteristics of its own components (roots of trust). Reference-values are the things that you compare the "evidence side" with. So endorsements cannot be part of the "reference side". They have to look similar/identical though - otherwise the comparison becomes complex and brittle.

element-name = (
    ? label => text,
    ? vendor => text, ; namespace authority designation
    ? type => $module-type, ; Note: 'type' SHOULD include a namespace authority if 'vendor' is ommitted
    ? model => text,
    ? layer => int,
    ? index => int,
; **note: An extension point in element-name confuses verifiers' ability to match against evidence**
)
; label is defined in coswid schema (q: should we use a different value if the semantics differ?)
; type is defined in coswid schema
vendor=110
model=111
layer=112
index=113

element-value = (
  ? version => text,
  ? svn => int,
  ? raw-value-entry,
  ? digests => digests-entry,
  ? flags => bytes .bits operational-flags,
;  * $$element-value-extension ; **note do we need an extension point in element-value given there are extension points in endorsed-value and reference-value?**
)
version=114
svn=115
digests=116
flags=117

endorsed-value = {
  element-name,
  ? element-value, ; one endorser benefits from the element-value of another endorser
  ? any-attribute, ; defined in coswid schema - **note: this can be removed if we opt for using the extension point instead. ** NOTE(tho): agree
  * $$endorsed-value-extension ;How do vendor specific schemas allocate indices (keys)? We need to specify a range of keys with rules 'first come first served'
}

;**Note: a collection of reference values can be modeled using multiplicity of tags and/or claims, but we need to verify how to apply AND and OR logic for matching.**

reference-value = {
  element-name,
  element-value,
  * $$reference-value-extension,
}

raw-value-entry = (
  raw-value => bstr,
  ? raw-value-mask => bstr,
)
raw-value=118
raw-value-mask=119

operational-flags = &( ;requires functional compare
  not-configured: 0,
  not-secure: 1,
  recovery: 2,
  debug: 3,
)

digests-entry = [ hash-entry / [2* hash-entry] ]
; hash-entry is defined in coswid schema
